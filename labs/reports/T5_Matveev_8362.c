//-------------------------------------------------------
//    Выполнил: Матвеев Никита группа 8362
//    Задание: 5 "Разгрузка контейнеров"
//    Дата выполнения: 29.05.2023
//    Версия: 0.1
//-------------------------------------------------------
//    Последовательность команд для запуска программы
//        gcc T5_Matveev_8362.c -o T5_Matveev_8362 -pthread -lrt
//        chmod +x T5_Matveev_8362
//        ./T5_Matveev_8362
//-------------------------------------------------------
//    Реализованная программа устанавливает три программных таймера с определенным интервалом
//         времени Т, по истечении которого в вызывающий поток (main) запускает новый поток
//         «создания контейнера» - container(). Таймер создается с помощью
//         функции timer_create() и активируется с помощью timer_settime().
//         После инициализации 3-х таймеров запускается функция диспетчера dispatcher() в главном потоке.
//         Этот поток и другие потоки, создаваемые таймерами, взаимодействуют друг с другом с помощью 2-х
//         условных переменных cond_1, cond_2 и мьютексов mutex_1, mutex_2, cond_lock.
//         Логика взаимодействия следующая:
//         В начале своей работы поток диспетчер ожидает сигнала на переменной cond_1, который выпускается
//         потоком контейнера в начале его работы и означает, что контейнер находится в ожидании загрузки;
//         После получения сигнала на переменной cond_1 поток диспетчера выводит сообщение о том, что
//         уведомление о поступлении контейнера в очередь им получено;
//         Далее, при условии освобождения mutex_2, поток диспетчера отправляет сигнал cond_2, который
//         обрабатывается первым в очереди потоком контейнера (т.к. ему принадлежал мьютекс mutex_2).
//         Контейнер, получивший обратно мьютекс mutex_2 начинает «разгрузку», которая длится установленное
//         время – UNLOAD_TIME. По истечении этого времени, mutex_2 освобождается и текущий поток
//         контейнера завершает свою работу.
//         По завершении каждой функции container() инкрементируется число разгруженных контейнеров - unloaded_containers.
//         При превышении этого числа установленного порога в параметре MAX_CONTAINERS, функция диспетчера прекращает свою
//         работу и переходит к остановке программы. Перед остановкой программы необходимо очистить память, поэтому
//         вызываются функции очистки памяти от созданных условных переменных, мьютексов и таймеров.
//         Так как в момент очистки переменных поток с функцией container() может ожидать cond_2, то необходимо
//         подать достаточное количество сигналов всем потокам, чтобы они "мягко" завершили выполнение
//         своей работы, а так как перед этим уничтожаются все таймеры,
//         то новые потоки созданы не будут.
//         Очередность контейнеров, как видно из приложенных логов, соблюдается в зависимости от очередности
//         прихода контейнеров на разгрузку. Потоки контейнеров встают в очередь, ожидая условную переменную cond_2,
//         и в зависимости от очередности ожидания, потоки просыпаются в том порядке, в котором вставали на ожидание.
//-------------------------------------------------------

#include <stdio.h>      //!< Стандартная библиотека ввода\вывода
#include <stdlib.h>     //!< Стандартная библиотека функций
#include <pthread.h>    //!< Библиотека для работы с потоками
#include <unistd.h>     //!< Библиотека API POSIX
#include <signal.h>     //!< Библотека сигналов
#include <semaphore.h>  //!< Библиотека семафоров
#include <errno.h>      //!< Библиотека для подробного вывода ошибок
#include <time.h>       //!< Библиотека функций времени

//! \brief Определение типа булевых переменных
typedef enum
{
    false = 0,
    true  = 1
} bool;

#define DEBUG true

#define MAX_CONTAINERS 5        //!< Количество контейнеров, после разгрузки которых диспетчер прекращает работу
pthread_cond_t cond_1, cond_2;
pthread_mutex_t mutex_1, mutex_2, cont_lock;
int T = 5;                      //!< Период появления контейнера в секундах
int UNLOAD_TIME = 2;            //!< Время разгрузки в секундах
char str_t[128] = "";           //!< Буфер для отображения времени
long int t_time;
int unloaded_containers = 0;    //!< Количество отгруженных контейнеров

void print_time ();
void container (int ID);
void* dispatcher ();

int main (int argc, char *argv[]) {
    print_time ();
    printf ("Старт программы\n\n");
//    Запуск трех периодических таймеров со схемой уведомления
//    «Создание потока».
//    Каждый таймер запускает поток - создание контейнера.
    struct sigevent event[3];
    struct itimerspec itime[3];
    timer_t timer_id[3];
    int container_id;
    for (container_id = 0; container_id < 3; container_id++)
    {
        //-- Задание схемы уведомления "Создание потока"
        event[container_id].sigev_notify = SIGEV_THREAD;
        //-- Ссылка на функцию для создания потоком
        event[container_id].sigev_notify_function = &container;
        //-- Аргумент для передачи потоку
        event[container_id].sigev_value.sival_int = container_id;
        //-- Если == NULL, то указатель на структуру с атрибутами потока
        event[container_id].sigev_notify_attributes = NULL;
        int timer = timer_create(CLOCK_REALTIME, &(event[container_id]), &(timer_id[container_id]));
        //-- Определение периода активации ~ c*/
        itime[container_id].it_value.tv_sec = 1;
        itime[container_id].it_value.tv_nsec = 500 * 1000 * 1000;
        //-- Определение длительности интервала - T*i c
        itime[container_id].it_interval.tv_sec = T;
        itime[container_id].it_interval.tv_nsec = 0;
        //-- Запуск таймера со схемой уведомления SIGEV_THREAD
        timer_settime (timer_id[container_id], 0, &(itime[container_id]),
        NULL);
    }
    pthread_cond_init (&cond_1, NULL);
    pthread_cond_init (&cond_2, NULL);
    pthread_mutex_init (&mutex_1, NULL);
    pthread_mutex_init (&mutex_2, NULL);
    pthread_mutex_init (&cont_lock, NULL);
    dispatcher ();
    for (int i = 0; i < 3; i++) {
        timer_delete (timer_id[i]);
    }
    pthread_cond_destroy (&cond_1);
    //-- Необходимо послать сигнал потокам, которые ожидают на cond_2,
    //-- чтобы успешно завершить выполнение программы
    for (int i = 0; i < 3; i++) {
        pthread_mutex_lock (&mutex_2);
        pthread_cond_signal (&cond_2);
        pthread_mutex_unlock (&mutex_2);
        sleep (1);
    }
    pthread_cond_destroy (&cond_2);
    pthread_mutex_destroy (&mutex_1);
    pthread_mutex_destroy (&mutex_2);
    pthread_mutex_destroy (&cont_lock);
    printf ("Завершение программы\n");
    return EXIT_SUCCESS;
}
void print_time ()
{
    t_time = time (NULL);
    strftime (str_t, 128, "%X", localtime(&t_time));
    printf ("%s: ", str_t);
}

//-- Контейнер, поток создается таймером
void container (int ID)
{
    pthread_mutex_lock (&cont_lock);
    if (unloaded_containers > MAX_CONTAINERS) {
        pthread_mutex_unlock (&cont_lock);
        return;
    }
    pthread_mutex_unlock (&cont_lock);
    int conteiner_ID = ID;
    pthread_mutex_lock (&mutex_1);
    print_time ();
    printf ("### Контейнер _%d_ ожидает диспетчера (thread %ld).\n\n",
    conteiner_ID, pthread_self ());
    //-- Контейнер прибыл, диспетчеру посылается запрос, сигнал условной переменной cond_1
    pthread_cond_signal (&cond_1);
    pthread_mutex_unlock (&mutex_1);
    //-- Ожидание разрешения диспетчера, блокировка на условной переменной cond_2
    pthread_mutex_lock (&mutex_2);
    pthread_cond_wait (&cond_2, &mutex_2);
    //-- Контейнер разгружается
    print_time ();
    printf ("### Контейнер _%d_ разгружается ... (thread %ld).\n\n",
    conteiner_ID, pthread_self ());
    sleep (UNLOAD_TIME);
    print_time ();
    printf ("### Контейнер _%d_ разгружен! (thread %ld).\n\n",
    conteiner_ID, pthread_self ());
    pthread_mutex_lock (&cont_lock);
    unloaded_containers++;
    pthread_mutex_unlock (&cont_lock);
    printf ("# Отгружено контейнеров: %d\n", unloaded_containers);
    pthread_mutex_unlock (&mutex_2);
}

 void* dispatcher ()
{
    while(1) {
        //-- Диспетчер ждет прибытия контейнера
        pthread_mutex_lock (&mutex_1);
        pthread_cond_wait (&cond_1, &mutex_1);
        print_time ();
        printf ("# Диспетчер получил уведомление о необходимости разгрузки. \n");
        pthread_mutex_unlock (&mutex_1);
        //-- Диспетчер посылает разрешение на разгрузку
        pthread_mutex_lock (&mutex_2);
        print_time ();
        printf ("# Диспетчер отправляет разрешение на разгрузку.\n");
        pthread_cond_signal (&cond_2);
        pthread_mutex_unlock (&mutex_2);
        if (unloaded_containers >= MAX_CONTAINERS) {
            printf ("# Диспетчер прекращает работу.\n");
            return NULL;
        }
    }
}

//LOG:
//     22:06:56: Старт программы
//
//     22:06:57: ### Контейнер _0_ ожидает диспетчера (thread 140541838878464).
//
//     22:06:57: ### Контейнер _1_ ожидает диспетчера (thread 140541830485760).
//
//     22:06:57: ### Контейнер _2_ ожидает диспетчера (thread 140541822093056).
//
//     22:06:57: # Диспетчер получил уведомление о необходимости разгрузки.
//     22:06:57: # Диспетчер отправляет разрешение на разгрузку.
//     22:06:57: ### Контейнер _0_ разгружается ... (thread 140541838878464).
//
//     22:06:59: ### Контейнер _0_ разгружен! (thread 140541838878464).
//
//     # Отгружено контейнеров: 1
//     22:07:02: ### Контейнер _0_ ожидает диспетчера (thread 140541838878464).
//
//     22:07:02: # Диспетчер получил уведомление о необходимости разгрузки.
//     22:07:02: # Диспетчер отправляет разрешение на разгрузку.
//     22:07:02: ### Контейнер _1_ разгружается ... (thread 140541830485760).
//
//     22:07:02: ### Контейнер _2_ ожидает диспетчера (thread 140541597579008).
//
//     22:07:02: # Диспетчер получил уведомление о необходимости разгрузки.
//     22:07:02: ### Контейнер _1_ ожидает диспетчера (thread 140541813700352).
//
//     22:07:04: ### Контейнер _1_ разгружен! (thread 140541830485760).
//
//     # Отгружено контейнеров: 2
//     22:07:04: # Диспетчер отправляет разрешение на разгрузку.
//     22:07:04: ### Контейнер _2_ разгружается ... (thread 140541822093056).
//
//     22:07:06: ### Контейнер _2_ разгружен! (thread 140541822093056).
//
//     # Отгружено контейнеров: 3
//     22:07:07: ### Контейнер _0_ ожидает диспетчера (thread 140541822093056).
//
//     22:07:07: ### Контейнер _1_ ожидает диспетчера (thread 140541830485760).
//
//     22:07:07: ### Контейнер _2_ ожидает диспетчера (thread 140541589186304).
//
//     22:07:07: # Диспетчер получил уведомление о необходимости разгрузки.
//     22:07:07: # Диспетчер отправляет разрешение на разгрузку.
//     22:07:07: ### Контейнер _0_ разгружается ... (thread 140541838878464).
//
//     22:07:09: ### Контейнер _0_ разгружен! (thread 140541838878464).
//
//     # Отгружено контейнеров: 4
//     22:07:12: ### Контейнер _0_ ожидает диспетчера (thread 140541838878464).
//
//     22:07:12: # Диспетчер получил уведомление о необходимости разгрузки.
//     22:07:12: # Диспетчер отправляет разрешение на разгрузку.
//     22:07:12: ### Контейнер _1_ ожидает диспетчера (thread 140541580793600).
//
//     22:07:12: ### Контейнер _2_ разгружается ... (thread 140541597579008).
//
//     22:07:12: ### Контейнер _2_ ожидает диспетчера (thread 140541572400896).
//
//     22:07:12: # Диспетчер получил уведомление о необходимости разгрузки.

